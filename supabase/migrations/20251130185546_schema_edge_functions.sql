create type "public"."media_slot" as enum ('card_front', 'card_back');

drop trigger if exists "create_review_trigger" on "public"."cards";

drop function if exists "public"."create_review_for_card"();

create table "public"."media" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "member_id" uuid,
    "card_id" bigint,
    "deck_id" bigint,
    "bucket" text not null,
    "path" text not null,
    "deleted_at" timestamp with time zone,
    "slot" media_slot
);


alter table "public"."media" enable row level security;

alter table "public"."cards" drop column "has_back_image";

alter table "public"."cards" drop column "has_front_image";

alter table "public"."cards" add column "attributes" jsonb;

CREATE UNIQUE INDEX media_pkey ON public.media USING btree (id);

alter table "public"."media" add constraint "media_pkey" PRIMARY KEY using index "media_pkey";

alter table "public"."media" add constraint "media_card_id_fkey" FOREIGN KEY (card_id) REFERENCES cards(id) not valid;

alter table "public"."media" validate constraint "media_card_id_fkey";

alter table "public"."media" add constraint "media_deck_id_fkey" FOREIGN KEY (deck_id) REFERENCES decks(id) not valid;

alter table "public"."media" validate constraint "media_deck_id_fkey";

alter table "public"."media" add constraint "media_member_id_fkey" FOREIGN KEY (member_id) REFERENCES members(id) not valid;

alter table "public"."media" validate constraint "media_member_id_fkey";

set check_function_bodies = off;

create or replace view "public"."card_with_images" as  SELECT c.id,
    c.created_at,
    c.updated_at,
    c.front_text,
    c.back_text,
    c.deck_id,
    c.member_id,
    c.rank,
    c.front_delta,
    c.back_delta,
    c.attributes,
    front.bucket AS front_image_bucket,
    front.path AS front_image_path,
    back.bucket AS back_image_bucket,
    back.path AS back_image_path
   FROM ((cards c
     LEFT JOIN media front ON (((front.card_id = c.id) AND (front.slot = 'card_front'::media_slot) AND (front.deleted_at IS NULL))))
     LEFT JOIN media back ON (((back.card_id = c.id) AND (back.slot = 'card_back'::media_slot) AND (back.deleted_at IS NULL))));


CREATE OR REPLACE FUNCTION public.reindex_deck_ranks(p_deck_id bigint)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
declare
  v_step numeric := 1000;  -- spacing between ranks
begin
  with ordered as (
    select
      id,
      row_number() over (order by rank, id) as rn
    from public.cards
    where deck_id = p_deck_id
  )
  update public.cards c
  set rank = o.rn * v_step
  from ordered o
  where c.id = o.id;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.soft_delete_media_before_card_delete()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  UPDATE media
  SET
    deleted_at = now(),
    card_id    = NULL
  WHERE card_id = OLD.id
    AND deleted_at IS NULL;

  RETURN OLD;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.card_rank_between(p_deck_id bigint, p_left_card_id bigint, p_right_card_id bigint)
 RETURNS numeric
 LANGUAGE plpgsql
AS $function$declare
  v_left_rank  numeric;
  v_right_rank numeric;
begin
  -- No neighbors (empty deck) -> choose some base rank
  if p_left_card_id is null and p_right_card_id is null then
    return 1000;
  end if;

  if p_left_card_id is not null then
    select c.rank
    into v_left_rank
    from public.cards c
    where c.id = p_left_card_id
      and c.deck_id = p_deck_id;
  end if;

  if p_right_card_id is not null then
    select c.rank
    into v_right_rank
    from public.cards c
    where c.id = p_right_card_id
      and c.deck_id = p_deck_id;
  end if;

  -- If both are still null, the deck has no cards matching those ids
  if v_left_rank is null and v_right_rank is null then
    raise exception 'card_rank_between: neither left nor right card found for deck %', p_deck_id;
  end if;

  -- Insert at start: only right neighbor
  if v_left_rank is null then
    return v_right_rank - 1;
  end if;

  -- Insert at end: only left neighbor
  if v_right_rank is null then
    return v_left_rank + 1;
  end if;

  if v_left_rank >= v_right_rank then
    raise exception using
      message = 'CARD_RANK_INVALID_ORDER',
      errcode = 'P0001';  -- user-defined / generic error code class
  end if;

  return (v_left_rank + v_right_rank) / 2;
end;$function$
;

CREATE OR REPLACE FUNCTION public.reorder_card(p_card_id bigint, p_left_card_id bigint, p_right_card_id bigint)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$declare
  v_uid      uuid := auth.uid();
  v_rank     numeric;
  v_deck_id  bigint;
  v_left_id  bigint := p_left_card_id;
  v_right_id bigint := p_right_card_id;
begin
  if v_uid is null then
    raise exception 'Not authenticated';
  end if;

  -- Find deck & ensure the card belongs to this user
  select deck_id
  into v_deck_id
  from public.cards
  where id = p_card_id
    and member_id = v_uid;

  if v_deck_id is null then
    raise exception 'Card not found or not owned by user';
  end if;

  -- optional: guard against using the card as its own neighbor
  if v_left_id = p_card_id then
    v_left_id := null;
  end if;

  if v_right_id = p_card_id then
    v_right_id := null;
  end if;

  -- serialize within this deck to avoid rank races
  perform pg_advisory_xact_lock(v_deck_id);

  -- Special case: both neighbors null → send to end of deck
  if v_left_id is null and v_right_id is null then
    select c.rank
    into v_rank
    from public.cards c
    where c.deck_id = v_deck_id
      and c.id <> p_card_id
    order by c.rank desc
    limit 1;

    -- deck might only contain this card → just keep it at some base rank
    if v_rank is null then
      v_rank := 1000; -- or keep its existing rank if you prefer
    else
      v_rank := v_rank + 1; -- append to end
    end if;

  else
    -- Normal path: use card_rank_between with neighbors
    begin
      v_rank := public.card_rank_between(v_deck_id, v_left_id, v_right_id);
      if v_rank is null then
        raise exception 'card_rank_between returned NULL';
      end if;

    exception
      when sqlstate 'P0001' then
        -- known ordering problem → reindex & retry
        perform public.reindex_deck_ranks(v_deck_id);
        v_rank := public.card_rank_between(v_deck_id, v_left_id, v_right_id);
        if v_rank is null then
          raise exception 'card_rank_between returned NULL (post-reindex)';
        end if;

      when others then
        -- real error → bubble up
        raise;
    end;
  end if;

  update public.cards
  set rank = v_rank,
      updated_at = now()
  where id = p_card_id;
end;$function$
;

CREATE OR REPLACE FUNCTION public.reserve_card(p_deck_id bigint, p_left_card_id bigint, p_right_card_id bigint)
 RETURNS TABLE(out_id bigint, out_rank numeric)
 LANGUAGE plpgsql
AS $function$declare
  v_rank numeric;
  v_uid  uuid := auth.uid();
begin
  if v_uid is null then
    raise exception 'Not authenticated';
  end if;

  -- serialize within this deck to avoid rank races
  perform pg_advisory_xact_lock(p_deck_id);

  -- compute rank (with one-time rebalance fallback)
  begin
    v_rank := public.card_rank_between(p_deck_id, p_left_card_id, p_right_card_id);
  
  exception
    -- Only handle our *known* rank-ordering issue here
    when sqlstate 'P0001' then
      -- reindex ranks for this deck, then retry
      perform public.reindex_deck_ranks(p_deck_id);
      v_rank := public.card_rank_between(p_deck_id, p_left_card_id, p_right_card_id);

    -- anything else is a real error and should bubble up
    when others then
      raise;
  end;

  -- insert placeholder and capture values into OUT vars
  insert into public.cards (member_id, deck_id, rank, front_text, back_text)
  values (v_uid, p_deck_id, v_rank, '', '')
  returning public.cards.id, public.cards.rank
  into out_id, out_rank;

  -- **emit** one row to the caller
  return next;

  -- end the function (optional in PL/pgSQL after RETURN NEXT)
  return;
end;$function$
;

grant delete on table "public"."media" to "anon";

grant insert on table "public"."media" to "anon";

grant references on table "public"."media" to "anon";

grant select on table "public"."media" to "anon";

grant trigger on table "public"."media" to "anon";

grant truncate on table "public"."media" to "anon";

grant update on table "public"."media" to "anon";

grant delete on table "public"."media" to "authenticated";

grant insert on table "public"."media" to "authenticated";

grant references on table "public"."media" to "authenticated";

grant select on table "public"."media" to "authenticated";

grant trigger on table "public"."media" to "authenticated";

grant truncate on table "public"."media" to "authenticated";

grant update on table "public"."media" to "authenticated";

grant delete on table "public"."media" to "service_role";

grant insert on table "public"."media" to "service_role";

grant references on table "public"."media" to "service_role";

grant select on table "public"."media" to "service_role";

grant trigger on table "public"."media" to "service_role";

grant truncate on table "public"."media" to "service_role";

grant update on table "public"."media" to "service_role";

create policy "Enable delete for users based on user_id"
on "public"."media"
as permissive
for delete
to public
using ((( SELECT auth.uid() AS uid) = member_id));


create policy "Enable insert for authenticated users only"
on "public"."media"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for all users"
on "public"."media"
as permissive
for select
to public
using (true);


create policy "Enable update for users with member_id"
on "public"."media"
as permissive
for update
to authenticated
using ((( SELECT auth.uid() AS uid) = member_id));


CREATE TRIGGER trg_card_delete_soft_delete_media BEFORE DELETE ON public.cards FOR EACH ROW EXECUTE FUNCTION soft_delete_media_before_card_delete();

CREATE TRIGGER set_member_id_on_media BEFORE INSERT ON public.media FOR EACH ROW EXECUTE FUNCTION set_member_id();


